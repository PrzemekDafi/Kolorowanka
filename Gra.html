<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8">
<title>Power of Lovable - Dafi</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
html, body {
height: 100%;
margin: 0;
padding: 0;
overflow: hidden;
}
body {
width: 100vw;
height: 100vh;
position: relative;
font-family: 'Press Start 2P', monospace;
background: #222;
}
#background-img {
position: fixed;
left: 0; top: 0;
width: 100vw; height: 100vh;
object-fit: cover;
z-index: 0;
pointer-events: none;
user-select: none;
}
#arcade-frame {
position: fixed;
left: 50%;
bottom: 0;
transform: translateX(-50%);
width: 1100px;
height: auto;
z-index: 2;
pointer-events: none;
user-select: none;
}
#gameContainer {
position: fixed;
z-index: 1;
left: 50%;
}
#gameCanvas {
display: block;
width: 100%;
height: 100%;
}
#loading {
position: fixed;
left: 50%; top: 50%;
transform: translate(-50%, -50%);
width: auto; /* Zmieniono na auto, aby dopasować do treści */
padding: 25px 25px; /* Dodano padding */
background-color: rgba(0, 136, 255, 0.8); /* Szare, półprzezroczyste tło */
color: #fff; /* Biały tekst dla lepszej czytelności */
font-size: 24px; /* Dopasuj rozmiar czcionki */
border-radius: 0px; /* Zaokrąglone rogi */
text-align: center;
display: flex;
align-items: center;
justify-content: center;
z-index: 100;
}

#info {
position: fixed;
left: 50%; top: 30%;
transform: translate(-50%, -50%);
width: auto; /* Zmieniono na auto, aby dopasować do treści */
padding: 25px 25px; /* Dodano padding */
background-color: rgba(0, 136, 255, 0.8); /* Szare, półprzezroczyste tło */
color: #fff; /* Biały tekst dla lepszej czytelności */
font-size: 24px; /* Dopasuj rozmiar czcionki */
border-radius: 0px; /* Zaokrąglone rogi */
text-align: center;
z-index: 20;
pointer-events: none; /* Niech nie blokuje interakcji z grą */
white-space: wrap; /* Zapobiega zawijaniu tekstu */
}


   #restart {
position: fixed;
left: 50%; top: 50%;
text-transform: uppercase;
transform: translate(-50%, -50%);
width: auto; /* Zmieniono na auto, aby dopasować do treści */
padding: 25px 25px; /* Dodano padding */
background-color: rgba(0, 136, 255, 0.9); /* Szare, półprzezroczyste tło */
color: #fff; /* Biały tekst dla lepszej czytelności */
font-size: 24px; /* Dopasuj rozmiar czcionki */
border-radius: 0px; /* Zaokrąglone rogi */
text-align: center;
z-index: 20;
pointer-events: auto;
}
#shareBtn {
      font-size:18px;
      padding:5px 15px;
      margin:5px;
      font-family:'Press Start 2P', monospace;
    }
    button {
      font-size:18px;
      padding:5px 15px;
      margin:5px;
      font-family:'Press Start 2P', monospace;
    }
  </style>
</head>
<body>
<img id="background-img" src="img/bg-gra.jpg" alt="Tło arcade">
<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="450" style="display:none;"></canvas>
</div>
<img id="arcade-frame" src="img/arcade.png" alt="Arcade Frame">
<div id="loading" style="display:block;">Ładowanie gry...</div>
<div id="info" style="display:none;">Zbieraj filtry, zgniataj plastik!<br>Jak grać? Strzałki: ← / → ruch, ↑ skok</div>
<button id="restart" style="display:none;">Zagraj ponownie</button>
    <div id="scoreWindow" style="display:none; position:fixed; left:50%; top:50%; transform:translate(-50%, -50%); width:900px; height:900px; background:#222; z-index:101; border-radius:15px; box-shadow:0 0 40px #000; overflow:hidden;">
    <div id="scoreWindow" style="position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 900px;
    height: 900px;
    background: rgb(38 161 252 / 95%);
    z-index: 101;
    border-radius: 0;
    box-shadow: rgb(255 255 255) 10px 10px 0px;
    overflow: hidden;">
    <img id="scoreImage" src="img/score.png" alt="Score image" style="float:left; width:300px; height:900px; margin:50px 30px;" />
    <div style="margin-left:360px; margin-top:120px; color:#fff; font-size:28px;" id="scoreBoard"></div>
    <div style="position:absolute; bottom:70px; left:360px;">Pochwal się swoim wynikiem!
      <button class="shareBtn" onclick="shareScore('facebook')">Facebook</button>
      <button class="shareBtn" onclick="shareScore('x')">X</button>
      <button class="shareBtn" onclick="shareScore('tiktok')">TikTok</button>
      <button class="shareBtn" onclick="shareScore('instagram')">Instagram</button>
    </div>
    <button onclick="document.getElementById('scoreWindow').style.display='none';" style="position:absolute;top:15px;right:30px;font-size:28px;">X</button>
    <button onclick="document.getElementById('scoreWindow').style.display='none';" style="position:absolute;top:35px;right:30px;font-size:28px;">X</button>
  </div>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

<script>
  // Automatyczne pozycjonowanie canvasa
 function positionGameCanvas() {
  var arcade = document.getElementById('arcade-frame');
  var gameContainer = document.getElementById('gameContainer');
  var canvas = document.getElementById('gameCanvas');
  var arcadeW = 1191, arcadeH = 1285;
  var screenX = 190, screenY = 464, screenW = 800, screenH = 450;
  var actualRect = arcade.getBoundingClientRect();
  var scale = actualRect.width / arcadeW;
  var gameLeft = actualRect.left + (screenX * scale);
  var gameTop = actualRect.bottom - ((arcadeH - screenY) * scale);
  var gameWidth = screenW * scale;
  var gameHeight = screenH * scale;
  gameContainer.style.left = gameLeft + "px";
  gameContainer.style.top  = gameTop + "px";
  gameContainer.style.width  = gameWidth + "px";
  gameContainer.style.height = gameHeight + "px";
  canvas.style.width  = "800px";
  canvas.style.height = "450px";
  }
  window.addEventListener('resize', positionGameCanvas);
  window.addEventListener('DOMContentLoaded', positionGameCanvas);

  let totalScore=0, collectedFilters=0, collectedHearts=0, collectedTimers=0, killedEnemies=0;
  let timerInterval;


  const imageSources = {
    filterkid_walk1: "img/filterkid_walk1.png",
  filterkid_walk2: "img/filterkid_walk2.png",
  filterkid_rest: "img/filterkid_rest.png",
  filterkid_soft_jump: "img/filterkid_soft_jump.png",
  filterkid_dead: "img/filterkid_dead.png",
  ground_block: "img/ground_block.png",
  obstacle_block_1: "img/obstacle_block_1.png",
  obstacle_block_2: "img/obstacle_block_2.png",
  obstacle_block_3: "img/obstacle_block_3.png",
  obstacle_block_4: "img/obstacle_block_4.png",
  obstacle_block_5: "img/obstacle_block_5.png",
  obstacle_block_6: "img/obstacle_block_6.png",
  island_block: "img/island_block.png",
  island_block_crack: "img/island_block_crack.png",
  spike: "img/spike.png",
  school: "img/school.png",
  filter_token: "img/filter_token.png",
  heart_item: "img/heart_item.png",
  clock_item: "img/clock_item.png",
  plastic_enemy: "img/plastic_enemy.png",
    plastic_enemy_crush: "img/plastic_enemy_crush.png",
  sky_bg: "img/sky_bg.png",
  far_bg: "img/far_bg.png",
  mid_bg: "img/mid_bg.png",
  par_tree1: "img/par_tree1.png",
  par_tree2: "img/par_tree2.png",
  par_tree3: "img/par_tree3.png",
  par_cloud1: "img/par_cloud1.png",
  par_cloud2: "img/par_cloud2.png",
  par_cloud3: "img/par_cloud3.png",
  par_car:     "img/par_car.png",
  par_ship:    "img/par_ship.png",
  par_bird:    "img/par_bird.png",
  par_house:   "img/par_house.png"
};
const IMAGES = {};
function preloadImages(sources, whenDone) {
  let loaded = 0, total = Object.keys(sources).length;
  for (let name in sources) {
    IMAGES[name] = new Image();
    IMAGES[name].onload = () => { if (++loaded === total) whenDone(); };
    IMAGES[name].onerror = () => { if (++loaded === total) whenDone(); };
    IMAGES[name].src = sources[name];
  }
}

const SCREEN_W = 800, SCREEN_H = 450, GRID = 40;
const PLAYER_W = 28, PLAYER_H = 68, GROUND_Y = SCREEN_H - GRID;
const LEVEL_WIDTH = 7000;
function fromGround(yTiles) { return GROUND_Y - GRID * yTiles; }
const level = {
  filter_token: [ {x:25,y:5}, ],
  ground_blocks: [],
  obstacle_blocks: [
  {type:1,x:0,y:6},{type:2,x:0,y:7},{type:3,x:1,y:7}, {type:5,x:15,y:4},{type:5,x:3,y:6},
  {type:1,x:21,y:7},{type:2,x:22,y:7},{type:3,x:23,y:7},
  {type:1,x:28,y:7},{type:2,x:29,y:7},{type:3,x:30,y:7},
  {type:1,x:150,y:7},{type:2,x:151,y:7},{type:3,x:152,y:7},
  {type:1,x:154,y:7},{type:2,x:155,y:7},{type:3,x:156,y:7},
  {type:1,x:181,y:7},
  {type:1,x:10,y:6},{type:2,x:11,y:6},{type:3,x:12,y:6},
  {type:1,x:36,y:6},{type:2,x:37,y:6},{type:3,x:38,y:6},
  {type:1,x:56,y:6},{type:2,x:57,y:6},{type:3,x:58,y:6},
  {type:1,x:87,y:6},{type:2,x:88,y:6},{type:3,x:89,y:6},
  {type:1,x:118,y:6},{type:2,x:119,y:6},{type:3,x:120,y:6},

  {type:5,x:145,y:5},{type:6,x:146,y:5},
  {type:1,x:20,y:4},
  {type:1,x:25,y:4},{type:5,x:26,y:4},{type:5,x:27,y:4},{type:5,x:28,y:4},{type:5,x:29,y:4},{type:5,x:30,y:4},{type:3,x:31,y:4},
  {type:2,x:40,y:4},{type:6,x:45,y:4},
  {type:4,x:53,y:4},{type:5,x:54,y:4},{type:5,x:55,y:4},{type:6,x:56,y:4},
  {type:5,x:61,y:4},{type:5,x:69,y:4},{type:5,x:70,y:4},
  {type:1,x:4,y:3},{type:3,x:9,y:3},
  {type:1,x:18,y:3},{type:5,x:19,y:3},{type:5,x:20,y:3},{type:5,x:21,y:3},{type:3,x:22,y:3},
  {type:5,x:26,y:3},{type:5,x:27,y:3},
  {type:4,x:37,y:3},{type:5,x:46,y:3},{type:5,x:47,y:3},{type:5,x:48,y:3},{type:5,x:49,y:3},{type:5,x:50,y:3},{type:5,x:51,y:3},
  {type:1,x:54,y:3},{type:2,x:55,y:3},{type:3,x:56,y:3},
  {type:1,x:62,y:3},{type:5,x:63,y:3},{type:5,x:64,y:3},{type:5,x:65,y:3},{type:5,x:66,y:3},
  {type:5,x:68,y:3},{type:5,x:69,y:3},{type:5,x:70,y:3},
  {type:2,x:84,y:3},{type:3,x:85,y:3},

  {type:1,x:92,y:3},{type:2,x:93,y:3},

  {type:1,x:17,y:2},{type:2,x:18,y:2},{type:5,x:19,y:2},{type:5,x:20,y:2},{type:5,x:21,y:2},{type:5,x:22,y:2},{type:5,x:23,y:2},{type:3,x:24,y:2},
  {type:5,x:27,y:2},{type:5,x:28,y:2},{type:5,x:29,y:2},

  {type:2,x:38,y:2},
  {type:4,x:53,y:2},

  {type:1,x:61,y:2},{type:2,x:62,y:2},{type:2,x:63,y:2},{type:2,x:64,y:2},{type:3,x:65,y:2},

  {type:5,x:77,y:2},
  {type:1,x:91,y:2},{type:2,x:92,y:2},{type:3,x:93,y:2},

    //uporządkowane
    {type:1,x:72,y:2},{type:3,x:80,y:2},
    {type:1,x:83,y:3},{type:3,x:80,y:2},
    {type:1,x:93,y:2},{type:5,x:97,y:2},{type:1,x:96,y:6},{type:4,x:99,y:5},{type:4,x:100,y:5},{type:6,x:101,y:5},
    {type:1,x:101,y:3},{type:2,x:102,y:4},{type:2,x:103,y:5},
                     {type:5,x:102,y:3},{type:6,x:103,y:4},
                                      {type:6,x:103,y:3},
                                      {type:6,x:103,y:2},
                                      {type:6,x:103,y:1},
    {type:1,x:124,y:4},{type:3,x:129,y:4},
    {type:4,x:124,y:3},{type:5,x:125,y:3},{type:5,x:126,y:3},{type:5,x:127,y:3},{type:6,x:128,y:3},
    {type:1,x:133,y:2},  {type:4,x:133,y:0}, {type:4,x:133,y:1},
    {type:6,x:138,y:2}, {type:6,x:138,y:3}, {type:6,x:138,y:4}, {type:1,x:133,y:5},{type:3,x:138,y:5},
    {type:1,x:133,y:8}, {type:3,x:138,y:8},
    {type:3,x:139,y:4}, {type:6,x:139,y:3},{type:6,x:139,y:2},{type:6,x:140,y:2},{type:3,x:141,y:2},
    {type:6,x:142,y:6},
    {type:1,x:145,y:2}, {type:2,x:146,y:2}, {type:6,x:147,y:2},
     {type:1,x:154,y:4}, {type:1,x:154,y:2}, {type:3,x:157,y:4},
  ],
 islands: [
  {x:5,y:4,len:4}, {x:7,y:7,len:5},
  {x:20,y:7,len:1}, {x:25,y:7,len:5}, {x:26,y:7,len:4},
  {x:42,y:7,len:4},
  {x:73,y:3,len:7}, {x:73,y:7,len:2}, {x:75,y:7,len:2},
  {x:97,y:7,len:4},  {x:99,y:3,len:4},
  {x:113,y:3,len:4}, 
  {x:120,y:3,len:2}, 
  {x:120,y:7,len:4},   {x:125,y:5,len:5},
  {x:134,y:3,len:4},  {x:134,y:6,len:4}, {x:134,y:9,len:4},
  {x:141,y:7,len:1}, {x:146,y:7,len:2},
  {x:150,y:3,len:4},  {x:155,y:5,len:2},
  {x:176,y:7,len:3},

],
  spikes: [
    {x:6,y:0},{x:7,y:0},{x:8,y:0},
    {x:48,y:0},{x:49,y:0},{x:50,y:0},
    {x:60,y:0},{x:61,y:0},{x:62,y:0},
    {x:87,y:0},{x:88,y:0},{x:89,y:0},

    {x:94,y:4},
    {x:111,y:0},{x:112,y:0},{x:113,y:0},
    {x:112,y:3},{x:117,y:3},{x:118,y:3},{x:119,y:3}
  ],

filter_tokens: [{x:15,y:2},{x:27,y:3},{x:34,y:2},{x:52,y:2},{x:67,y:4},{x:120,y:2},{x:175,y:3},{x:300,y:5},{x:400,y:2}],
  heart_items: [{x:0,y:10},{x:34,y:3},{x:65,y:3},{x:80,y:2},{x:120,y:3}],
  clock_items: [{x:200,y:4},{x:135,y:4},],
  school: {x:170,y:2, w:8, h:6},
  plastic_enemies: [
    {type:"ground",x:7,y:0,dir:1,min:7,max:19},   {type:"ground", x:14, y:0, dir:1, min:14, max:17},
{type:"ground", x:33, y:0, dir:1, min:33, max:36},	{type:"ground", x:36, y:0, dir:1, min:36, max:39},
{type:"ground", x:43, y:0, dir:1, min:43, max:46},    {type:"ground", x:51, y:0, dir:1, min:51, max:54},
{type:"ground", x:64, y:0, dir:1, min:64, max:67},    {type:"ground", x:76, y:0, dir:1, min:76, max:79},
{type:"ground", x:98, y:0, dir:1, min:98, max:101},    {type:"ground", x:105, y:0, dir:1, min:105, max:108},     
{type:"ground", x:122, y:0, dir:1, min:122, max:125},    {type:"ground", x:129, y:0, dir:1, min:129, max:132},     
{type:"ground", x:140, y:0, dir:1, min:140, max:143},
    {type:"ground", x:144, y:0, dir:1, min:144, max:147},     {type:"ground", x:155, y:0, dir:1, min:155, max:158},
    {type:"ground",x:20,y:0,dir:1,min:20,max:22},
    {type:"island",island:0,pos:1,dir:1},
    {type:"island",island:1,pos:1,dir:1},{type:"island",island:2,pos:1,dir:1},{type:"island",island:3,pos:0,dir:-1},
    {type:"island",island:4,pos:1,dir:1},{type:"island",island:5,pos:1,dir:1},{type:"island",island:6,pos:0,dir:-1},
    {type:"island",island:7,pos:1,dir:1},{type:"island",island:8,pos:1,dir:1},{type:"island",island:9,pos:0,dir:-1},
    {type:"island",island:11,pos:1,dir:1},{type:"island",island:12,pos:1,dir:1},{type:"island",island:13,pos:0,dir:1},
    {type:"island",island:14,pos:1,dir:1},{type:"island",island:15,pos:1,dir:1},{type:"island",island:16,pos:0,dir:1},
    {type:"island",island:17,pos:1,dir:1},


  ]
};
for(let i=0;i<LEVEL_WIDTH/(GRID*3);i++)
  if (!level.spikes.some(function(s){ return i*3===s.x && s.y===0; }))
    level.ground_blocks.push({x:i*3, y:0});

// ---- RESZTA LOGIKI I KOD GRY (NIEZMIENIONY) ----
function spawnParallax(){
if(Math.random() < 0.01){ // większa szansa!
let farIds = ["par_cloud1","par_cloud2","par_cloud3","par_ship","par_bird"];
let midIds = [
"par_tree1","par_tree1","par_tree2","par_tree2","par_tree3","par_tree3",
"par_car","par_house","par_house"
];
let layer = Math.random() < 0.5 ? "far" : "mid";
let images = (layer=="far") ? farIds : midIds;
let img = images[Math.floor(Math.random()*images.length)];
let x = camX + SCREEN_W + 100 + Math.random()*500;
let y;
if(layer === "far"){
y = 40 + Math.random()*120;
} else {
if(img === "par_car") {
y = GROUND_Y - 100;
} else if(img.startsWith("par_tree")){
y = GROUND_Y - 130; // dla drzew
} else if(img === "par_house") {
y = GROUND_Y - 100; // dla domu, lub dopasuj wg grafik
} else {
y = 190 + Math.random()*130;
}
}
let speed = (img.startsWith("par_tree") || img === "par_house") ? 0 :
(layer=="far" ? 0.1+Math.random()*0.4 : 2.3+Math.random()*1.3);
parallaxObjects.push({layer, x, y, img, speed});
}
}


let filterkid, camX, timer, filters_collected, lives, filterkid_solid, gameWon, gameOver, dying, dyingTy, dyingVy;
let levelEnemies, levelSpikes, levelTokens, levelBlocks, levelObstacles, levelHearts, levelClocks, levelIslands, levelSchool;
let islandTiles = [], parallaxObjects = [];
let keys = {}, startingX = 40, startingY = fromGround(0) - PLAYER_H;
let wantJump=false, jumpPressed=false, jumpTime=0, JUMP_MAX=12;
let itemAnimOffset = 0; // Dodane dla animacji przedmiotów
let brokenParticles = []; // Dodane dla efektu rozpadu
let fireworks = []; // Dodane dla fajerwerków

function resetGame(){
filterkid = { x:startingX, y:startingY, vx:0, vy:0, w:PLAYER_W, h:PLAYER_H, onGround:false, facing:1, dead:false };
camX = 0; timer = 120; filters_collected = 0; lives = 2;
filterkid_solid = false; gameWon = false; gameOver = false; dying = false;
totalScore = 0; collectedFilters = 0; collectedHearts = 0; collectedTimers = 0; killedEnemies = 0;

levelBlocks = level.ground_blocks.map(o => ({...o}));
levelSpikes = level.spikes.map(o => ({...o}));
levelTokens = level.filter_tokens.map(o => ({...o}));
levelClocks = level.clock_items.map(o => ({...o}));
levelHearts = level.heart_items.map(o => ({...o}));
levelIslands = JSON.parse(JSON.stringify(level.islands));
levelSchool = {...level.school};
parallaxObjects = [];
brokenParticles = [];
fireworks = [];

levelObstacles = JSON.parse(JSON.stringify(level.obstacle_blocks));
levelObstacles.forEach(o => { o.hits = 3; o.cracked = false; o.toBreak = false; });

islandTiles = [];
levelIslands.forEach((isl, idx) => {
for (let k = 0; k < isl.len; k++) {
islandTiles.push({ islandIndex: idx, x: isl.x + k, y: isl.y, hits: 2, cracked: false, toBreak: false });
}
});

levelEnemies = [];
level.plastic_enemies.forEach(e_template => {
let e;
if (e_template.type === "ground")
e = {...e_template, t: e_template.type};
else if (e_template.type === "island")
e = {t:"island", island:e_template.island, pos:e_template.pos, dir:e_template.dir};

e.isFalling = false;
e.fallVy = 0;
e.crushing = false;
e.crushTimer = 0;

let baseY;
if (e.t === "ground") {
baseY = fromGround(0);
} else if (e.t === "island") {
baseY = fromGround(levelIslands[e.island].y);
}
e.absY = baseY - PLAYER_H;
levelEnemies.push(e);
});
document.getElementById('restart').style.display='';
wantJump = false; jumpPressed = false; jumpTime = 0;

// Generowanie losowych zegarów
let clockPositions = [];
for (let i = 0; i < 5; i++) {
let x = Math.floor(Math.random() * (LEVEL_WIDTH / GRID - 20)) + 10;
let y = 2 + Math.floor(Math.random() * 5);
clockPositions.push({x: x, y: y});
}
levelClocks = clockPositions;

// Generowanie losowych filtrów
let filterPositions = [];
for (let i = 0; i < 10; i++) {
let x = Math.floor(Math.random() * (LEVEL_WIDTH / GRID - 20)) + 10;
let y = 2 + Math.floor(Math.random() * 5);
filterPositions.push({x: x, y: y});
}
levelTokens = filterPositions;
}

function triggerDeath(){
filterkid.dead = true; dying = true; dyingTy = filterkid.y; dyingVy = -12;
}

document.getElementById('restart').onclick = function() {
resetGame();
document.getElementById('scoreWindow').style.display = 'none';
};

document.addEventListener('keydown',function(e){ keys[e.key] = true; });
document.addEventListener('keyup',function(e){ keys[e.key] = false; });
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
function gameloop(){
update();
render();
requestAnimationFrame(gameloop);
}
function drawImgContain(img, x, y, w, h) {
if (!img || !img.complete || !img.naturalWidth) return;
let iw = img.width, ih = img.height;
let scale = Math.min(w / iw, h / ih);
let nw = iw * scale, nh = ih * scale;
let dx = x + (w-nw)/2, dy = y + (h-nh)/2;
ctx.drawImage(img, dx, dy, nw, nh);
}
function drawOrRect(imgName, x, y, w, h, drawRect) {
if(IMAGES[imgName] && IMAGES[imgName].complete && IMAGES[imgName].naturalWidth)
drawImgContain(IMAGES[imgName], x, y, w, h);
else drawRect();
}
function drawBlock(x,y){drawOrRect('ground_block', x, y, GRID*3, GRID, function(){ ctx.fillStyle="#915921";ctx.fillRect(x,y,GRID*3,GRID); ctx.strokeStyle="#37250d";ctx.strokeRect(x,y,GRID*3,GRID); });}
function drawObstacle(type,x,y,cracked){
var name = cracked ? 'island_block_crack' : ('obstacle_block_'+type);
var color = ["#c33","#0c3","#39c","#993","#999","#666"][type-1];
drawOrRect(name, x, y, GRID, GRID, function(){
ctx.save();
ctx.translate(x, y);
ctx.fillStyle = cracked ? '#cc5' : color;
ctx.fillRect(0, 0, GRID, GRID);
ctx.strokeStyle = "#222";
ctx.strokeRect(0, 0, GRID, GRID);
ctx.restore();
});
}

function drawIslandBlock(x,y, cracked){let name = cracked ? 'island_block_crack' : 'island_block'; drawOrRect(name, x, y, GRID, GRID, function(){ ctx.fillStyle = cracked ? '#cc5' : '#e7e763';ctx.strokeStyle = cracked ? '#996' : '#bdb948';ctx.fillRect(x,y,GRID,GRID);ctx.strokeRect(x,y,GRID,GRID); });}
function drawSpike(x,y){drawOrRect('spike', x, y, GRID, GRID, function(){ctx.save();ctx.translate(x,y);ctx.fillStyle="#eee";ctx.beginPath();ctx.moveTo(0,GRID-3);ctx.lineTo(GRID/2,5);ctx.lineTo(GRID,GRID-3);ctx.closePath();ctx.fill();ctx.strokeStyle="#999";ctx.lineWidth=2;ctx.strokeRect(0,0,GRID,GRID);ctx.restore();});}
function drawSchool(x,y,w,h){
w = (w||1); h = (h||1);
drawOrRect('school', x, y, 60*w, 40*h, function(){
ctx.save();ctx.translate(x,y);ctx.fillStyle="#ffeab2";ctx.fillRect(0,0,60*w,40*h);ctx.fillStyle="#d52312";ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(30*w,-26*h);ctx.lineTo(60*w,0);ctx.closePath();ctx.fill();ctx.strokeRect(0,0,60*w,40*h);ctx.fillStyle="#333";ctx.font="bold 13px 'Press Start 2P'";ctx.fillText("SZKOŁA",10+(w-1)*22,24*h);ctx.restore();
});
}
function drawFilterToken(x,y){drawOrRect('filter_token',x+10,y+2,22,60,function(){ctx.save();ctx.translate(x+10,y+2);ctx.fillStyle="#30a7e2";ctx.fillRect(0,0,18,50);ctx.fillStyle="#efef1e";ctx.fillRect(3,2,10,44);ctx.strokeStyle="#298fa2";ctx.strokeRect(0,0,18,50);ctx.restore();});}
function drawHeart(x,y){drawOrRect('heart_item',x+9,y+11,36,36,function(){ctx.save();ctx.translate(x+9,y+11);ctx.fillStyle="#e43c2c";ctx.beginPath();ctx.arc(13,12,14,Math.PI*0.89,Math.PI*2.1);ctx.arc(31,12,14,Math.PI*1.06,Math.PI*2.04,true);ctx.lineTo(22,32);ctx.closePath();ctx.fill();ctx.restore();});}
function drawClock(x,y){drawOrRect('clock_item',x+13,y+10,30,30,function(){ctx.save();ctx.translate(x+13,y+10); ctx.fillStyle="#fff";ctx.beginPath();ctx.arc(16,15,15,0,2*Math.PI);ctx.fill();ctx.strokeStyle="#186bb0";ctx.stroke(); ctx.fillStyle="#19376d";ctx.font="bold 25px Arial";ctx.fillText("⏰",4,26);ctx.restore();});}
function drawPlasticEnemy(x,y,e){
if (e.crushing && IMAGES.plastic_enemy_crush && IMAGES.plastic_enemy_crush.complete && IMAGES.plastic_enemy_crush.naturalWidth) {
drawImgContain(IMAGES.plastic_enemy_crush, x+2, y, PLAYER_W, PLAYER_H);
} else {
drawOrRect('plastic_enemy',x+2,y,PLAYER_W,PLAYER_H,function(){
ctx.save();ctx.translate(x+2,y);ctx.fillStyle="#dbf5ff";ctx.fillRect(0,0,PLAYER_W,PLAYER_H);ctx.strokeStyle="#333";ctx.strokeRect(0,0,PLAYER_W,PLAYER_H);
ctx.fillStyle="#26aad3";ctx.fillRect(7,PLAYER_H-18,PLAYER_W-14,14);ctx.restore();
});
}
}

function drawFilterkidSprite(x, y, facing, state, step, dead){
let spr;
if(dead && IMAGES.filterkid_dead){ spr = "filterkid_dead"; }
else if(state === "walk"){ spr = (step === 0) ? "filterkid_walk1" : "filterkid_walk2"; }
else if(state === "rest"){ spr = "filterkid_rest"; }
else if(state === "jump"){ spr = "filterkid_soft_jump"; }
else { spr = "filterkid_walk1"; }
ctx.save();
if(facing === -1) {
ctx.translate(x + PLAYER_W, y);
ctx.scale(-1, 1);
drawImgContain(IMAGES[spr], 0, 0, PLAYER_W, PLAYER_H);
} else {
drawImgContain(IMAGES[spr], x, y, PLAYER_W, PLAYER_H);
}
ctx.restore();
}
function drawParallaxBg(camX){
let skyimg = IMAGES['sky_bg'];
if(skyimg && skyimg.complete && skyimg.naturalWidth){
var scale=Math.max(canvas.width/skyimg.width, GROUND_Y/skyimg.height);
var w=skyimg.width*scale, h=skyimg.height*scale;
ctx.drawImage(skyimg,(canvas.width-w)/2,0,w,GROUND_Y);
}
let bgimg = IMAGES['far_bg'];
if(bgimg && bgimg.complete && bgimg.naturalWidth){
for(var i=-2; i < Math.ceil(canvas.width / bgimg.width) + 3; i++){
var px = i*bgimg.width - (camX/8.5);
ctx.drawImage(bgimg, px, 0);
}
}
let midimg = IMAGES['mid_bg'];
if(midimg && midimg.complete && midimg.naturalWidth){
for(var i=-2; i < Math.ceil(canvas.width / midimg.width) + 3; i++){
var px = i*midimg.width - (camX/2.15);
ctx.drawImage(midimg, px, GROUND_Y - midimg.height);
}
}
for(let i=0;i<parallaxObjects.length;i++){
let obj = parallaxObjects[i];
if(obj.layer==="far") obj.x -= obj.speed*0.5;
else obj.x -= obj.speed*1.1;
let px = obj.layer==="far" ? obj.x - camX/7 : obj.x - camX/2.1;
let img = IMAGES[obj.img];
if(img && img.complete && img.naturalWidth)
ctx.drawImage(img, px, obj.y);
}
parallaxObjects = parallaxObjects.filter(obj => obj.x > camX-500 && obj.x < camX+SCREEN_W+500);
}

// Rysowanie
function render(){
camX = filterkid.x - SCREEN_W / 2 + PLAYER_W / 2;
if (camX < 0) camX = 0;
if (camX > LEVEL_WIDTH - SCREEN_W) camX = LEVEL_WIDTH - SCREEN_W;
ctx.clearRect(0, 0, SCREEN_W, SCREEN_H);
drawParallaxBg(camX);
drawBlock(-camX, GROUND_Y);
for (let i = 0; i < LEVEL_WIDTH / (GRID * 3); i++) {
drawBlock(i * GRID * 3 - camX, GROUND_Y);
}
levelBlocks.forEach(b => drawBlock(b.x*GRID-camX, fromGround(b.y)));
levelObstacles.forEach(b => drawObstacle(b.type,b.x*GRID-camX, fromGround(b.y)-GRID, b.cracked));
islandTiles.forEach(isl => drawIslandBlock(isl.x*GRID-camX, fromGround(isl.y), isl.cracked));
levelSpikes.forEach(s => drawSpike(s.x*GRID-camX, fromGround(s.y)));

itemAnimOffset = Math.sin(Date.now() / 300) * 5; // animacja lewitacji
levelTokens.forEach(t => drawFilterToken(t.x*GRID-camX, fromGround(t.y)+itemAnimOffset));
levelHearts.forEach(h => drawHeart(h.x*GRID-camX, fromGround(h.y)+itemAnimOffset));
levelClocks.forEach(c => drawClock(c.x*GRID-camX, fromGround(c.y)+itemAnimOffset));

levelEnemies.forEach(e => {
let x = e.t=="island" ? (levelIslands[e.island].x+e.pos)*GRID : e.x*GRID;
drawPlasticEnemy(x-camX, e.absY, e);
});
drawSchool(levelSchool.x*GRID-camX, fromGround(levelSchool.y)-40*levelSchool.h, levelSchool.w, levelSchool.h);
let playerState = "rest", playerStep=0;
if(filterkid.vx!==0) {playerState="walk"; playerStep = Math.floor(Date.now()/120)%2;}
if(!filterkid.onGround) playerState="jump";
if(dying){
drawFilterkidSprite(filterkid.x-camX, dyingTy, filterkid.facing, "dead", playerStep, true);
} else {
drawFilterkidSprite(filterkid.x-camX, filterkid.y, filterkid.facing, playerState, playerStep, false);
}

// Rysowanie cząsteczek
for (let i = 0; i < brokenParticles.length; i++) {
let p = brokenParticles[i];
ctx.fillStyle = p.color;
ctx.fillRect(p.x - camX, p.y, p.size, p.size);
}

// Rysowanie fajerwerków
for (let i = 0; i < fireworks.length; i++) {
let f = fireworks[i];
f.particles.forEach(p => {
ctx.beginPath();
ctx.arc(p.x - camX, p.y, p.size, 0, Math.PI * 2);
ctx.fillStyle = p.color;
ctx.fill();
});
}
ctx.save();
ctx.font = "20px 'Press Start 2P'";

// Miganie na czerwono, gdy timer ≤ 15 sekund
let flashing = false;
if (timer <= 15) {
  // Miganie co 500 ms
  flashing = Math.floor(Date.now() / 500) % 2 === 0;
}

ctx.fillStyle = flashing ? "red" : "#fff";
ctx.shadowColor = "#333";
ctx.shadowOffsetX = 2;
ctx.shadowOffsetY = 2;
ctx.shadowBlur = 0;
ctx.fillText("Czas: " + timer, 10, 30);

// Pozostałe teksty zawsze białe
ctx.fillStyle = "#fff";
ctx.fillText("Filtry: " + collectedFilters, 10, 60);
ctx.fillText("Życia: " + lives, 10, 90);
ctx.restore();


if(gameOver){
ctx.save();
ctx.fillStyle = "rgba(0,0,0,0.5)"; 
ctx.fillRect(0,0,SCREEN_W,SCREEN_H);
ctx.fillStyle = "#fff"; 
ctx.textAlign="center";
ctx.font="bold 40px 'Press Start 2P'";
ctx.shadowColor = "#30a7e2";
ctx.shadowOffsetX = 3;
ctx.shadowOffsetY = 3;
ctx.shadowBlur = 5;
ctx.fillText("KONIEC GRY!", SCREEN_W/2, SCREEN_H/2-30);
ctx.font="24px 'Press Start 2P'";
ctx.shadowBlur = 0;
ctx.fillText("Zacznij od nowa", SCREEN_W/2, SCREEN_H/2);
ctx.restore();
}
if(gameWon){
ctx.save();
ctx.fillStyle = "rgba(0,0,0,0.5)"; 
ctx.fillRect(0,0,SCREEN_W,SCREEN_H);
ctx.fillStyle = "#fff"; 
ctx.textAlign="center";
ctx.font="bold 40px 'Press Start 2P'";
ctx.shadowColor = "#30a7e2";
ctx.shadowOffsetX = 3;
ctx.shadowOffsetY = 3;
ctx.shadowBlur = 5;
ctx.fillText("GRATULACJE!", SCREEN_W/2, SCREEN_H/2-30);
ctx.font="24px 'Press Start 2P'";
ctx.shadowBlur = 0;
ctx.fillText("Zacznij od nowa", SCREEN_W/2, SCREEN_H/2);
ctx.restore();
}
}

function createBlockParticles(x, y, color) {
for (let i = 0; i < 10; i++) {
brokenParticles.push({
x: x + Math.random() * GRID,
y: y + Math.random() * GRID,
vx: (Math.random() - 0.5) * 5,
vy: Math.random() * -10,
size: 5 + Math.random() * 5,
color: color    });
}
}

// Funkcja do tworzenia fajerwerków
function createFireworks(x, y) {
const colors = ['#ff0', '#f00', '#0ff', '#f0f', '#0f0', '#fff'];
const color = colors[Math.floor(Math.random() * colors.length)];
let particles = [];
for (let i = 0; i < 50; i++) {
particles.push({
x: x,
y: y,
vx: (Math.random() - 0.5) * 10,
vy: (Math.random() - 0.5) * 10,
size: 2 + Math.random() * 3,
color: color
});
}
fireworks.push({
x: x,
y: y,
particles: particles,
timer: 60
});
}

// --- Główna funkcja aktualizująca stan gry
function collideRect(a,b,w1,h1,w2,h2){return (a.x < b.x+w2 && a.x+w1 > b.x && a.y < b.y+h2 && a.y+h1 > b.y);}
function update(){
if(gameOver || gameWon) {
// Update fireworks
if(gameWon && Math.random() < 0.05) {
const schoolX = levelSchool.x * GRID + (levelSchool.w * GRID * 1.5) / 2;
const schoolY = fromGround(levelSchool.y) - (levelSchool.h * GRID * 1.1) / 2;
createFireworks(schoolX + (Math.random()-0.5)*150, schoolY - (Math.random()*100));
}
for(let i = 0; i < fireworks.length; i++) {
let f = fireworks[i];
f.particles.forEach(p => {
p.x += p.vx;
p.y += p.vy;
p.vy += 0.5;
p.size *= 0.95;
});
f.timer--;
}
fireworks = fireworks.filter(f => f.timer > 0);
return;
}
spawnParallax();
if(dying){
dyingTy += dyingVy; dyingVy += 2.2;
if(dyingTy > SCREEN_H+30){ dying = false; loseLifeToStart(); }
return;
}

// Update particles
for (let i = 0; i < brokenParticles.length; i++) {
let p = brokenParticles[i];
p.x += p.vx;
p.y += p.vy;
p.vy += 0.8;
}
brokenParticles = brokenParticles.filter(p => p.y < SCREEN_H + 50);

// ruch gracza
let speed = 3.2;
filterkid.vx = 0;
if(keys['ArrowLeft'])  { filterkid.vx = -speed; filterkid.facing = -1; }
if(keys['ArrowRight']) { filterkid.vx =  speed; filterkid.facing =  1; }
filterkid.x += filterkid.vx;
if(keys['ArrowUp'] && filterkid.onGround && !jumpPressed){
wantJump = true; jumpPressed = true; jumpTime=0;
}
if(!keys['ArrowUp']){ jumpPressed=false; wantJump=false; jumpTime=0; }
if(wantJump){
if(jumpTime===0)      filterkid.vy = -18.5;
if(jumpTime < JUMP_MAX){ filterkid.vy -= 1.45; jumpTime++; }
else                  { wantJump = false; }
}
filterkid.vy += 2.2;
let dy = filterkid.vy, nextY = filterkid.y + dy;
let minDy = dy, groundY = null, landed = false;
let allPlatforms = [
...levelBlocks.map(b => ({ x: b.x * GRID, y: fromGround(b.y), w: GRID * 3, h: GRID })),
...levelObstacles.map(b => ({ x: b.x * GRID, y: fromGround(b.y) - GRID, w: GRID, h: GRID })),
...islandTiles.map(b => ({ x: b.x * GRID, y: fromGround(b.y), w: GRID, h: GRID }))
];

// Kolizja z góry (lądowanie)
allPlatforms.forEach(p => {
if (filterkid.x + filterkid.w > p.x && filterkid.x < p.x + p.w &&
filterkid.y + filterkid.h <= p.y && nextY + filterkid.h >= p.y) {
let curDy = p.y - (filterkid.y + filterkid.h);
if (curDy < minDy) {
minDy = curDy;
groundY = p.y;
landed = true;
}
}
});

// Kolizja z boku
allPlatforms.forEach(p => {
if (filterkid.x + filterkid.w > p.x && filterkid.x < p.x + p.w &&
filterkid.y + filterkid.h > p.y + 8 && filterkid.y < p.y + p.h - 8 && filterkid.vx !== 0) {
filterkid.x -= filterkid.vx;
}
});

// Kolizja od dołu (uderzenie głową)
levelObstacles.forEach(b => {
let bx = b.x * GRID, by = fromGround(b.y) - GRID, bh = GRID;
if (
filterkid.x + filterkid.w > bx &&
filterkid.x < bx + GRID &&
filterkid.y < by + bh &&
filterkid.y + filterkid.h > by + bh &&
filterkid.vy < 0
) {
filterkid.y = by + bh + 1;
filterkid.vy = 1;
wantJump = false;
jumpTime = JUMP_MAX;

if (b.hits > 0) {
b.hits--;
if (b.hits === 2) b.cracked = true;
if (b.hits <= 0) {
b.toBreak = true;
createBlockParticles(bx, by, ["#c33","#0c3","#39c","#993","#999","#666"][b.type-1]);
}
}
}
});

levelObstacles = levelObstacles.filter(o => !o.toBreak);

islandTiles.forEach(island => {
let bx = island.x * GRID, by = fromGround(island.y), bw = GRID, bh = GRID;
if(filterkid.x + filterkid.w > bx && filterkid.x < bx + bw &&
filterkid.y < by + bh && filterkid.y + filterkid.h > by + bh && filterkid.vy < 0){
filterkid.y = by + bh + 1; filterkid.vy = 1; wantJump = false; jumpTime = JUMP_MAX;
if(island.hits > 0) {
island.hits--;
if(island.hits == 1) island.cracked = true;
if(island.hits == 0) {
island.toBreak = true;
createBlockParticles(bx, by, "#e7e763");
}
}
}
});
islandTiles = islandTiles.filter(tile => !tile.toBreak);

if(landed){
filterkid.y = groundY-filterkid.h; filterkid.vy=0; filterkid.onGround = true; wantJump = false; jumpTime = 0;
} else {
filterkid.y += filterkid.vy;
filterkid.onGround = false;
}

for(var s=0;s<levelSpikes.length;s++){
var b = levelSpikes[s];
var bx = b.x * GRID, by = fromGround(b.y);
if(collideRect(filterkid,{x:bx,y:by},filterkid.w,filterkid.h,GRID,GRID)){
triggerDeath();return;
}
}
for (let i=0; i<levelEnemies.length; i++) {
let e = levelEnemies[i];

if(e.crushing){
e.crushTimer--;
if(e.crushTimer <= 0){ levelEnemies.splice(i,1); i--; }
continue;
}
if (e.isFalling) {
e.fallVy += 2.2;
e.absY += e.fallVy;
} else {
let groundFound = false;
let enemyX = e.t === "island" ? (levelIslands[e.island].x + e.pos) * GRID : e.x * GRID;
let enemyY = e.t === "island" ? fromGround(levelIslands[e.island].y) : fromGround(0);
let nextPos = {x: enemyX, y: enemyY};

allPlatforms.forEach(p => {
if (nextPos.x + PLAYER_W > p.x && nextPos.x < p.x + p.w &&
nextPos.y === p.y) {
groundFound = true;
}
});

if (groundFound) {
if(e.t=="ground"||e.t=="obstacle"){
e.x += e.dir*0.04;
if(e.x<=e.min){ e.x = e.min; e.dir=1;}
if(e.x>=e.max){ e.x = e.max; e.dir=-1;}
} else if(e.t=="island"){
e.pos += e.dir*0.04;
let isl = levelIslands[e.island];
if(e.pos<=0) {e.pos=0;e.dir=1;}
if(e.pos>=isl.len-1) {e.pos=isl.len-1;e.dir=-1;}
}
} else {
e.isFalling = true;
}
}
if (e.absY > SCREEN_H + 90) {
levelEnemies.splice(i, 1);
i--;
continue;
}
let enemyX = e.t=="island" ? (levelIslands[e.island].x+e.pos)*GRID : e.x*GRID;
let enemyY = e.absY;
if(collideRect(filterkid,{x: enemyX, y: enemyY},filterkid.w,filterkid.h,PLAYER_W,PLAYER_H)){
if(filterkid.vy > 0 && filterkid.y+filterkid.h < enemyY+PLAYER_H/2){
filterkid.vy = -8;
e.crushing = true;
e.crushTimer = 60;
killedEnemies++;
continue;
} else {
triggerDeath();
return;
}
}
}
for(var i=0;i<levelTokens.length;i++){
var t=levelTokens[i],tx=t.x*GRID,ty=fromGround(t.y)+10;
if(collideRect(filterkid,{x:tx,y:ty},filterkid.w,filterkid.h,22,60)){
collectedFilters++; levelTokens.splice(i,1); i--;
if(collectedFilters>=5) filterkid_solid = true;
}
}
for(var i=0;i<levelHearts.length;i++){
var t=levelHearts[i],tx=t.x*GRID,ty=fromGround(t.y)+10;
if(collideRect(filterkid,{x:tx,y:ty},filterkid.w,filterkid.h,36,36)){
lives++; collectedHearts++; levelHearts.splice(i,1); i--;
}
}
for(var i=0;i<levelClocks.length;i++){
var t=levelClocks[i],tx=t.x*GRID,ty=fromGround(t.y)+10;
if(collideRect(filterkid,{x:tx,y:ty},filterkid.w,filterkid.h,30,30)){
timer+=10; collectedTimers++; levelClocks.splice(i,1); i--;
}
}
var sx = levelSchool.x*GRID, sy = fromGround(levelSchool.y);
var sw = (levelSchool.w||1)*GRID*1.5, sh = (levelSchool.h||1)*GRID*1.1;
if(collideRect(filterkid,{x:sx,y:sy-sh},filterkid.w,filterkid.h,sw,sh)){
gameWinLogic();
}
}

function loseLifeToStart(){
  if (gameOver || gameWon) return;

  lives--;

  if (lives < 0) {
    gameOver = true;
    gameWon = false;
    document.getElementById('restart').style.display='';
    totalScore = 3 * collectedFilters + 2 * collectedHearts + 2 * collectedTimers + killedEnemies;
    showScoreWindow();
  } else {
    timer = 120;
    filterkid.vy = 0;
    filterkid.vx = 0;
    filterkid_solid = false;
    filterkid.dead = false;

    // 🔹 usuń wrogów w promieniu 200px od miejsca śmierci
    const playerX = filterkid.x;
    const playerY = filterkid.y;
    levelEnemies = levelEnemies.filter(e => {
      let enemyX = e.t === "island"
        ? (levelIslands[e.island].x + e.pos) * GRID
        : e.x * GRID;
      let enemyY = e.absY;
      let distance = Math.sqrt(
        Math.pow(playerX - enemyX, 2) +
        Math.pow(playerY - enemyY, 2)
      );
      return distance > 200;
    });

    // 🔹 sprawdź, czy śmierć była na kolcach
    const onSpikes = levelSpikes.some(s =>
      collideRect(
        { x: playerX, y: playerY },
        { x: s.x * GRID, y: fromGround(s.y) },
        filterkid.w, filterkid.h,
        GRID, GRID
      )
    );

    if (onSpikes) {
      // Szukamy najbliższej bezpiecznej przeszkody
      let safeX = null;
      let safeY = null;
      for (let i = 0; i < levelObstacles.length; i++) {
        let o = levelObstacles[i];
        let ox = o.x * GRID;
        let oy = fromGround(o.y) - GRID; // pozycja kafla przeszkody

        // Sprawdź, czy na tej samej pozycji nie ma kolców
        const spikeHere = levelSpikes.some(s =>
          s.x * GRID === ox &&
          fromGround(s.y) === oy + GRID
        );

        if (o.toBreak === false && !spikeHere) {
          // cofamy o 3 kratki w lewo, z zabezpieczeniem przed <0
          safeX = Math.max(0, ox - (GRID * 3));
          safeY = oy - PLAYER_H;
          break;
        }
      }
      if (safeX !== null && safeY !== null) {
        filterkid.x = safeX;
        filterkid.y = safeY;
      } else {
        // Awaryjny respawn na startowej pozycji
        filterkid.x = startingX;
        filterkid.y = startingY;
      }
    } else {
      // W innych wypadkach respawn na punkcie startowym
      filterkid.x = startingX;
      filterkid.y = startingY;
    }
  }
}

function showScoreWindow(){
let div = document.getElementById('scoreBoard');
div.innerHTML =
`Twój wynik:<br><br>
   Filtry: <b>${collectedFilters}</b> × 3 = ${collectedFilters*3}<br>
   Serca: <b>${collectedHearts}</b> × 2 = ${collectedHearts*2}<br>
   Zegarki: <b>${collectedTimers}</b> × 2 = ${collectedTimers*2}<br>
   Wrogowie: <b>${killedEnemies}</b> × 1 = ${killedEnemies*1}<br>
   <hr style='border-color:#fff'>
   <b>Łącznie: ${totalScore} pkt</b>`;

setTimeout(() => {
document.getElementById('scoreWindow').style.display = '';
}, 3000);
}

function shareScore(target){
const scoreWindow = document.getElementById('scoreWindow');
html2canvas(scoreWindow).then(canvas => {
const imgData = canvas.toDataURL('image/png');
const text = `Mój wynik w Power of Lovable: ${totalScore} pkt! Spróbuj pobić mój rekord!`;

if (target === 'x') {
window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(imgData)}`, '_blank');
} else if (target === 'facebook') {
window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(imgData)}&quote=${encodeURIComponent(text)}`, '_blank');
} else if (target === 'tiktok') {
navigator.clipboard.writeText(text).then(() => {
alert("TikTok nie umożliwia web-share, wynik skopiowany. Spróbuj wkleić go w aplikacji!");
});
} else if (target === 'instagram') {
navigator.clipboard.writeText(text).then(() => {
alert("Wynik skopiowany. Otwórz Instagram i wklej go!");
});
}
});
}

preloadImages(imageSources, function(){
document.getElementById('loading').style.display='none';
document.getElementById('info').style.display='';
setTimeout(()=>{ document.getElementById('info').style.display='none'; },10000);
document.getElementById('gameCanvas').style.display='';
resetGame(); gameloop(); positionGameCanvas();
timerInterval = setInterval(function(){
if(!gameOver && !gameWon && !dying){
timer--;
if(timer<=0){
gameOver=true;
document.getElementById('restart').style.display='';
totalScore = 3*collectedFilters + 2*collectedHearts + 2*collectedTimers + killedEnemies;
showScoreWindow();
}
}
},1000);
});

function gameWinLogic() {
gameWon = true;
document.getElementById('restart').style.display = '';
totalScore = 3 * collectedFilters + 2 * collectedHearts + 2 * collectedTimers + killedEnemies;

// Pokaż napis "GRATULACJE!" na 3 sekundy
ctx.font = "bold 50px 'Press Start 2P'";
ctx.fillStyle = "#fff";
ctx.textAlign = "center";
ctx.fillText("GRATULACJE!", SCREEN_W / 2, SCREEN_H / 2);

setTimeout(() => {
showScoreWindow();
}, 3000);
}
    // Obsługa kliknięcia "Zagraj ponownie"
document.getElementById('restart').onclick = function () {
  // Schowaj przycisk i okno wyniku
  document.getElementById('restart').style.display = '';
  document.getElementById('scoreWindow').style.display = 'none';

  // Reset flag gry
  gameOver = false;
  gameWon = false;
  dying = false;

  // Uruchom ponowną grę
  resetGame();
};

</script>
</body>
</html>
